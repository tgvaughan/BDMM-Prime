/*
 * Copyright (C) 2019-2025 ETH Zurich
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package bdmmprime.util.operators;

import beast.base.core.Description;
import beast.base.core.Input;
import beast.base.inference.Operator;
import beast.base.inference.parameter.RealParameter;
import beast.base.util.Randomizer;

@Description("Proposal operator for RealParameters representing sequences of " +
        "change times which maintains the ordering of the times. Note that the " +
        "equlibrium distributions for n change times generated by this operator " +
        "are the probability distributions for the n order statistics of a " +
        "uniform distribution.")
public class ChangeTimeOperator extends Operator {

    public Input<RealParameter> changeTimesInput = new Input<>( "changeTimes",
            "RealParameter whose elements represent a (strictly) monotonically " +
                    "increasing sequence of change times.",
            Input.Validate.REQUIRED);

    public Input<Double> windowSizeInput = new Input<>("windowSize",
            "Size of window from which to draw new times for the first change time.",
            1.0);

    public Input<Double> scaleFactorInput = new Input<>("scaleFactor",
            "Used to scale differences between adjacent times. Scale factor " +
            "is chosen from between scaleFactor and 1/scaleFactor.",
            0.75);

    RealParameter changeTimes;

    @Override
    public void initAndValidate() {

        changeTimes = changeTimesInput.get();

        for (int idx=1; idx<changeTimes.getDimension(); idx++) {
            if (changeTimes.getValue(idx)<=changeTimes.getValue(idx-1))
                throw new IllegalArgumentException("ChangeTimeOperator can only be " +
                        "applied to RealParameters containing a strictly " +
                        "monotonically increasing sequence of values.");
        }
    }

    @Override
    public double proposal() {
        int idx = Randomizer.nextInt(changeTimes.getDimension());
        if (idx==0)
            return originProposal();
        else
            return deltaProposal(idx);
    }

    private double deltaProposal(int idx) {

        double minf = Math.min(scaleFactorInput.get(), 1.0/scaleFactorInput.get());
        double f = minf + Randomizer.nextDouble()*(1/minf - minf);

        double shift = (f-1)*(changeTimes.getValue(idx)-changeTimes.getValue(idx-1));

        if (changeTimes.getValue(changeTimes.getDimension()-1)>changeTimes.getUpper())
            return Double.NEGATIVE_INFINITY;

        for (int idxPrime=idx; idxPrime<changeTimes.getDimension(); idxPrime++)
            changeTimes.setValue(idxPrime, changeTimes.getValue(idxPrime)+shift);

        return -Math.log(f);
    }

    private double originProposal() {
        double delta = (Randomizer.nextDouble()-0.5)*windowSizeInput.get();
        if (changeTimes.getValue(0) + delta < changeTimes.getLower() ||
                changeTimes.getValue(changeTimes.getDimension()-1) + delta > changeTimes.getUpper())
            return Double.NEGATIVE_INFINITY;

        for (int idx=0; idx<changeTimes.getDimension(); idx++)
            changeTimes.setValue(idx, changeTimes.getValue(idx)+delta);

        return 0;
    }


}
